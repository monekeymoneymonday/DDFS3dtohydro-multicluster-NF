module hf_nf_reaction
  !------------------------------------------------------------------
  ! Processes interaction events generated by hf_nf_interaction and
  ! updates NF states plus corresponding frac_list elements based on
  ! simple traction/pressure criteria.
  !------------------------------------------------------------------
  use fracture_types
  use nf_types,          only: nf_list
  use hf_nf_interaction, only: event_queue
  use nf_embedding,      only: nf_elem_map
  use mech_bridge,       only: get_elem_stress
  implicit none
  private
  public :: process_events
contains

  subroutine process_events()
    integer :: iEv, nfIdx, hfIdx, elIdx
    real(dp) :: p_hf, sigma_n, tau, mu_eff
    real(dp) :: sigma(3,3), t_vec(3), nvec(3), shear_vec(3)

    if (.not.allocated(event_queue)) return

    do iEv = 1, size(event_queue)
       hfIdx = event_queue(iEv)%hf_elem
       nfIdx = event_queue(iEv)%nf_id
       if (nfIdx<1 .or. nfIdx>size(nf_list)) cycle
       elIdx = nf_elem_map(nfIdx)
       if (elIdx == 0) cycle   ! NF not embedded yet: skip

       !-----------------------------------------------------------
       ! Retrieve HF pressure and compute mechanical tractions on
       ! the NF element using the BEM stress influence coefficients.
       !-----------------------------------------------------------
       p_hf = frac_list(hfIdx)%pressure

       ! Get full stress tensor at NF element centre (global coords)
       call get_elem_stress(elIdx, sigma)

       ! Convert tensor to tractions on the NF plane
       nvec = frac_list(elIdx)%normal          ! unit normal (global)
       t_vec = matmul(sigma, nvec)             ! traction vector σ·n
       sigma_n = dot_product(t_vec, nvec)      ! normal stress (comp. +)
       shear_vec = t_vec - sigma_n * nvec      ! shear component
       tau = sqrt(sum(shear_vec**2))
       mu_eff = nf_list(nfIdx)%mu

       !-----------------------------------------------------------
       ! Opening criterion: -sigma_n + p_hf >= tensile_strength
       ! Slip criterion   : tau >= mu*sigma_n + cohesion
       !-----------------------------------------------------------
       logical :: do_open, do_slip
       do_open = (-sigma_n + p_hf) >= nf_list(nfIdx)%tensile
       do_slip = (tau >= mu_eff*sigma_n + nf_list(nfIdx)%cohesion)

       if (do_open) then
          nf_list(nfIdx)%state = 1   ! opened
          frac_list(elIdx)%is_active = .true.
          frac_list(elIdx)%aperture  = max(frac_list(elIdx)%aperture, nf_list(nfIdx)%aperture0)
       else if (do_slip) then
          nf_list(nfIdx)%state = 2   ! slipped
          frac_list(elIdx)%is_active = .true.
          frac_list(elIdx)%aperture  = max(frac_list(elIdx)%aperture, nf_list(nfIdx)%aperture0*1.5_dp)
       end if
    end do

    ! clear queue after processing
    if (allocated(event_queue)) deallocate(event_queue)
  end subroutine process_events

end module hf_nf_reaction 